{
  "app.ts": "// src\\app.ts\n\nimport { envs } from './core';\nimport { AppRoutes } from './routes';\nimport { Server } from './server';\n\n(() => {\n\tmain();\n})();\n\nfunction main(): void {\n\t// * At this point you can connect to your database for example MongoDB\n\n\tconst server = new Server({\n\t\tport: envs.PORT,\n\t\tapiPrefix: envs.API_PREFIX,\n\t\troutes: AppRoutes.routes\n\t});\n\tvoid server.start();\n}\n",
  "core/config/encrypt.adapter.ts": "import { createHash, randomBytes } from 'crypto';\n\nimport { TEN } from '../constants';\n\n// Generate a random salt\nconst salt = randomBytes(TEN).toString('hex');\n\n/**\n * Basic encryption adapter for password hashing and comparison.\n * Here you can use any encryption library you want.\n */\nexport const basicEncript = {\n\t/**\n\t * Generates a hash for a password with a salt.\n\t * @param password - The password to hash.\n\t * @returns - The hashed password.\n\t */\n\thashPassword: (password: string): string => {\n\t\t// Create the hash using the salt and the password\n\t\tconst hash = createHash('sha256')\n\t\t\t.update(salt + password)\n\t\t\t.digest('hex');\n\n\t\treturn hash;\n\t},\n\n\t/**\n\t * Compares a password with a given hash and salt.\n\t * @param password - The password to verify.\n\t * @param hash - The original hash to compare with.\n\t * @returns - True if the password matches, false otherwise.\n\t */\n\tcomparePassword: (password: string, hash: string): boolean => {\n\t\t// Create a new hash with the given salt and password\n\t\tconst newHash = createHash('sha256')\n\t\t\t.update(salt + password)\n\t\t\t.digest('hex');\n\n\t\t// Compare the new hash with the original hash\n\t\treturn newHash === hash;\n\t}\n};\n",
  "core/config/envs.adapter.ts": "import 'dotenv/config';\nimport { get } from 'env-var';\n\nexport const envs = {\n\tPORT: get('PORT').required().asPortNumber(),\n\tAPI_PREFIX: get('DEFAULT_API_PREFIX').default('/api/v1').asString(),\n\tNODE_ENV: get('NODE_ENV').default('development').asString(),\n\tJWT_SEED: get('JWT_SEED').required().asString()\n};\n",
  "core/config/envs.config.adapter.ts": "import { envs } from './envs.adapter';\n\ndescribe('tests in envs.config.test.ts', () => {\n\ttest('should return env options', () => {\n\t\texpect(envs).toEqual({\n\t\t\tPORT: 3000,\n\t\t\tAPI_PREFIX: '/api/v1/test',\n\t\t\tNODE_ENV: 'test'\n\t\t});\n\t});\n});\n",
  "core/config/index.ts": "export * from './envs.adapter';\nexport * from './encrypt.adapter';\nexport * from './jwt.adapter';\n",
  "core/config/jwt.adapter.ts": "import * as crypto from 'crypto';\n\nimport { FOUR, ONE_THOUSAND, SIXTY, THREE } from '../constants';\nimport { envs } from './envs.adapter';\n\nconst JWT_SEED = envs.JWT_SEED;\n\n/**\n * JWT adapter for basic authentication.\n */\nexport const basicJWT = {\n\t/**\n\t * Creates a JWT token.\n\t * @param {Record<string, unknown>} payload - The payload of the token.\n\t * @param {number} expiresIn - The token expiration time in seconds.\n\t * @returns {string} The generated JWT token.\n\t */\n\tgenerateToken: (payload: Record<string, unknown>, expiresIn: number = SIXTY * SIXTY): string => {\n\t\tconst header = { alg: 'HS256', typ: 'JWT' };\n\n\t\tconst exp = Math.floor(Date.now() / ONE_THOUSAND) + expiresIn;\n\t\tconst payloadWithExp = { ...payload, exp };\n\n\t\tconst headerEncoded = base64UrlEncode(JSON.stringify(header));\n\t\tconst payloadEncoded = base64UrlEncode(JSON.stringify(payloadWithExp));\n\n\t\tconst signature = crypto\n\t\t\t.createHmac('sha256', JWT_SEED)\n\t\t\t.update(`${headerEncoded}.${payloadEncoded}`)\n\t\t\t.digest('base64')\n\t\t\t.replace(/=/g, '')\n\t\t\t.replace(/\\+/g, '-')\n\t\t\t.replace(/\\//g, '_');\n\n\t\treturn `${headerEncoded}.${payloadEncoded}.${signature}`;\n\t},\n\n\t/**\n\t * Verifies a JWT token.\n\t * @param {string} token - The JWT token to verify.\n\t * @returns {Record<string, any> | null} The decoded payload if the token is valid, otherwise null.\n\t */\n\tvalidateToken: <T>(token: string): T | null => {\n\t\tconst [headerEncoded, payloadEncoded, signature] = token.split('.');\n\n\t\tconst signatureCheck = crypto\n\t\t\t.createHmac('sha256', JWT_SEED)\n\t\t\t.update(`${headerEncoded}.${payloadEncoded}`)\n\t\t\t.digest('base64')\n\t\t\t.replace(/=/g, '')\n\t\t\t.replace(/\\+/g, '-')\n\t\t\t.replace(/\\//g, '_');\n\n\t\tif (signature !== signatureCheck) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst payload = JSON.parse(base64UrlDecode(payloadEncoded));\n\t\treturn payload;\n\t}\n};\n\n/**\n * Encodes a string or Buffer to Base64 URL-safe format.\n * @param {string | Buffer} data - The data to encode.\n * @returns {string} The Base64 URL-safe encoded string.\n */\nfunction base64UrlEncode(data: string | Buffer): string {\n\tif (typeof data === 'string') {\n\t\treturn Buffer.from(data, 'utf8').toString('base64').replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n\t} else if (Buffer.isBuffer(data)) {\n\t\treturn data.toString('base64').replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n\t} else {\n\t\tthrow new Error('Unsupported data type for base64UrlEncode');\n\t}\n}\n\n/**\n * Decodes a Base64 URL-safe string.\n * @param {string} base64Url - The Base64 URL-safe encoded string.\n * @returns {string} The decoded string.\n */\nfunction base64UrlDecode(base64Url: string): string {\n\tconst base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/') + '==='.slice((THREE * base64Url.length) % FOUR);\n\treturn Buffer.from(base64, 'base64').toString('utf8');\n}\n",
  "core/constants/index.ts": "/* eslint-disable @typescript-eslint/no-magic-numbers */\n\nexport const ZERO = 0 as const;\nexport const ONE = 1 as const;\nexport const THREE = 3 as const;\nexport const FOUR = 4 as const;\nexport const SIX = 6 as const;\nexport const TEN = 10 as const;\nexport const SIXTY = 60 as const;\nexport const ONE_HUNDRED = 100 as const;\nexport const ONE_THOUSAND = 1000 as const;\n\nexport const REGEX_EMAIL = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/;\n\nexport enum HttpCode {\n\tOK = 200,\n\tCREATED = 201,\n\tNO_CONTENT = 204,\n\tBAD_REQUEST = 400,\n\tUNAUTHORIZED = 401,\n\tFORBIDDEN = 403,\n\tNOT_FOUND = 404,\n\tINTERNAL_SERVER_ERROR = 500\n}\n",
  "core/errors/custom.error.ts": "// src\\core\\errors\\custom.error.ts\n\nimport { HttpCode } from '../constants';\nimport { type ValidationType } from '../types';\n\ninterface AppErrorArgs {\n\tname?: string;\n\tstatusCode: HttpCode;\n\tmessage: string;\n\tisOperational?: boolean;\n\tvalidationErrors?: ValidationType[];\n}\n\nexport class AppError extends Error {\n\tpublic readonly name: string;\n\tpublic readonly statusCode: HttpCode;\n\tpublic readonly isOperational: boolean = true;\n\tpublic readonly validationErrors?: ValidationType[];\n\n\tconstructor(args: AppErrorArgs) {\n\t\tconst { message, name, statusCode, isOperational, validationErrors } = args;\n\t\tsuper(message);\n\t\tObject.setPrototypeOf(this, new.target.prototype);\n\t\tthis.name = name ?? 'Aplication Error';\n\t\tthis.statusCode = statusCode;\n\t\tif (isOperational !== undefined) this.isOperational = isOperational;\n\t\tthis.validationErrors = validationErrors;\n\t\tError.captureStackTrace(this);\n\t}\n\n\tstatic badRequest(message: string, validationErrors?: ValidationType[]): AppError {\n\t\treturn new AppError({ name: 'BadRequestError', message, statusCode: HttpCode.BAD_REQUEST, validationErrors });\n\t}\n\n\tstatic unauthorized(message: string): AppError {\n\t\treturn new AppError({ name: 'UnauthorizedError', message, statusCode: HttpCode.UNAUTHORIZED });\n\t}\n\n\tstatic forbidden(message: string): AppError {\n\t\treturn new AppError({ name: 'ForbiddenError', message, statusCode: HttpCode.FORBIDDEN });\n\t}\n\n\tstatic notFound(message: string): AppError {\n\t\treturn new AppError({ name: 'NotFoundError', message, statusCode: HttpCode.NOT_FOUND });\n\t}\n\n\tstatic internalServer(message: string): AppError {\n\t\treturn new AppError({ name: 'InternalServerError', message, statusCode: HttpCode.INTERNAL_SERVER_ERROR });\n\t}\n}\n",
  "core/errors/index.ts": "export * from './custom.error';\n",
  "core/index.ts": "export * from './config';\nexport * from './constants';\nexport * from './errors';\nexport * from './types';\n",
  "core/types/index.ts": "export interface ValidationType {\n\tfields: string[];\n\tconstraint: string;\n}\n\nexport interface SuccessResponse<T> {\n\tdata?: T;\n}\n\nexport interface ErrorResponse {\n\tname: string;\n\tmessage: string;\n\tvalidationErrors?: ValidationType[];\n\tstack?: string;\n}\n",
  "features/auth/domain/datasources/datasource.ts": "// src/features/auth/domain/datasources/datasource.ts\n\nimport { type LoginUserDto, type RegisterUserDto } from '../dtos';\nimport { type UserEntity, type AuthEntity } from '../entities';\n\nexport abstract class AuthDatasource {\n\tabstract register(dto: RegisterUserDto): Promise<AuthEntity>;\n\tabstract login(dto: LoginUserDto): Promise<AuthEntity>;\n\t// TODO: create a DTO for this method\n\tabstract getUserById(dto: string): Promise<UserEntity>;\n}\n",
  "features/auth/domain/dtos/index.ts": "export * from './register.dto';\nexport * from './login.dto';\n",
  "features/auth/domain/dtos/login.dto.ts": "import { AppError, type ValidationType, ZERO, REGEX_EMAIL, SIX } from '../../../../core';\nimport { type CoreDto } from '../../../shared';\n\n/**\n * DTOs must have a validate method that throws an error\n * if the data is invalid or missing required fields.\n */\nexport class LoginUserDto implements CoreDto<LoginUserDto> {\n\tprivate constructor(\n\t\tpublic readonly email: string,\n\t\tpublic readonly password: string\n\t) {\n\t\tthis.validate(this);\n\t}\n\n\tpublic validate(dto: LoginUserDto): void {\n\t\tconst errors: ValidationType[] = [];\n\t\tconst { email, password } = dto;\n\n\t\tif (!email || !REGEX_EMAIL.test(email)) {\n\t\t\terrors.push({ fields: ['email'], constraint: 'Email is not valid' });\n\t\t}\n\n\t\tif (!password || password.length < SIX) {\n\t\t\terrors.push({ fields: ['password'], constraint: 'Password is not valid' });\n\t\t}\n\n\t\tif (errors.length > ZERO) throw AppError.badRequest('Error validating user data', errors);\n\t}\n\n\t/**\n\t * This method creates a new instance of this DTO class with the given\n\t * properties from body or query parameters.\n\t * @param object\n\t * @returns A new instance of this DTO\n\t */\n\tpublic static create(object: Record<string, unknown>): LoginUserDto {\n\t\tconst { email, password } = object;\n\t\treturn new LoginUserDto(email as string, password as string);\n\t}\n}\n",
  "features/auth/domain/dtos/register.dto.ts": "import { AppError, type ValidationType, ZERO, REGEX_EMAIL, SIX } from '../../../../core';\nimport { type CoreDto } from '../../../shared';\n\n/**\n * DTOs must have a validate method that throws an error\n * if the data is invalid or missing required fields.\n */\nexport class RegisterUserDto implements CoreDto<RegisterUserDto> {\n\tprivate constructor(\n\t\tpublic readonly name: string,\n\t\tpublic readonly email: string,\n\t\tpublic readonly password: string\n\t) {\n\t\tthis.validate(this);\n\t}\n\n\tpublic validate(dto: RegisterUserDto): void {\n\t\tconst errors: ValidationType[] = [];\n\t\tconst { name, email, password } = dto;\n\n\t\tif (!name || name.length === ZERO) {\n\t\t\terrors.push({ fields: ['name'], constraint: 'Name is required' });\n\t\t}\n\n\t\tif (!email || !REGEX_EMAIL.test(email)) {\n\t\t\terrors.push({ fields: ['email'], constraint: 'Email is not valid' });\n\t\t}\n\n\t\tif (!password || password.length < SIX) {\n\t\t\terrors.push({ fields: ['password'], constraint: 'Password is not valid' });\n\t\t}\n\n\t\tif (errors.length > ZERO) throw AppError.badRequest('Error validating user data', errors);\n\t}\n\n\t/**\n\t * This method creates a new instance of this DTO class with the given\n\t * properties from body or query parameters.\n\t * @param object\n\t * @returns A new instance of this DTO\n\t */\n\tpublic static create(object: Record<string, unknown>): RegisterUserDto {\n\t\tconst { name, email, password } = object;\n\t\treturn new RegisterUserDto(name as string, email as string, password as string);\n\t}\n}\n",
  "features/auth/domain/entities/auth.entity.ts": "// src/features/auth/domain/entities/auth.entity.ts\n\nimport { type UserEntity } from './user.entity';\n\nexport class AuthEntity {\n\tconstructor(\n\t\tpublic readonly user: Omit<UserEntity, 'password'>,\n\t\tpublic readonly token: string\n\t) {}\n}\n",
  "features/auth/domain/entities/index.ts": "export * from './user.entity';\nexport * from './auth.entity';\n",
  "features/auth/domain/entities/user.entity.ts": "// src/features/auth/domain/entities/user.entity.ts\n\nimport { AppError, ZERO } from '../../../../core';\n\nexport class UserEntity {\n\tconstructor(\n\t\tpublic id: string,\n\t\tpublic name: string,\n\t\tpublic email: string,\n\t\tpublic emailVerified: boolean = false,\n\t\tpublic password: string,\n\t\tpublic role: string[],\n\t\tpublic avatar?: string\n\t) {}\n\n\t/**\n\t * If someone wants to work with this entity (map an object coming from my database),\n\t * let's make sure to do validations on its properties. …\n\t * @param obj - The object coming from my database\n\t * @returns UserEntity - A new UserEntity instance\n\t */\n\tpublic static fromJson(obj: Record<string, unknown>): UserEntity {\n\t\tconst { id, name, email, emailVerified, password, role, avatar } = obj;\n\t\tif (!id) {\n\t\t\tthrow AppError.badRequest('This entity requires an id', [{ constraint: 'id is required', fields: ['id'] }]);\n\t\t}\n\t\tif (!name || (name as string).length === ZERO) {\n\t\t\tthrow AppError.badRequest('This entity requires a name', [{ constraint: 'name is required', fields: ['name'] }]);\n\t\t}\n\t\tif (!email || (email as string).length === ZERO) {\n\t\t\tthrow AppError.badRequest('This entity requires an email', [\n\t\t\t\t{ constraint: 'email is required', fields: ['email'] }\n\t\t\t]);\n\t\t}\n\t\tif (emailVerified === undefined) {\n\t\t\tthrow AppError.badRequest('This entity requires an emailVerified', [\n\t\t\t\t{ constraint: 'emailVerified is required', fields: ['emailVerified'] }\n\t\t\t]);\n\t\t}\n\t\tif (!password || (password as string).length === ZERO) {\n\t\t\tthrow AppError.badRequest('This entity requires a password', [\n\t\t\t\t{ constraint: 'password is required', fields: ['password'] }\n\t\t\t]);\n\t\t}\n\t\tif (!role || (role as string).length === ZERO) {\n\t\t\tthrow AppError.badRequest('This entity requires a role', [{ constraint: 'role is required', fields: ['role'] }]);\n\t\t}\n\t\treturn new UserEntity(\n\t\t\tid as string,\n\t\t\tname as string,\n\t\t\temail as string,\n\t\t\temailVerified as boolean,\n\t\t\tpassword as string,\n\t\t\trole as string[],\n\t\t\tavatar as string\n\t\t);\n\t}\n}\n",
  "features/auth/domain/index.ts": "export * from './entities';\nexport * from './dtos';\nexport * from './datasources/datasource';\nexport * from './repositories/repository';\nexport * from './usecases';\n",
  "features/auth/domain/repositories/repository.ts": "// src/features/auth/domain/repositories/repository.ts\n\nimport { type LoginUserDto, type RegisterUserDto } from '../dtos';\nimport { type UserEntity, type AuthEntity } from '../entities';\n\nexport abstract class AuthRepository {\n\tabstract register(dto: RegisterUserDto): Promise<AuthEntity>;\n\tabstract login(dto: LoginUserDto): Promise<AuthEntity>;\n\t// TODO: create a DTO for this method\n\tabstract getUserById(dto: string): Promise<UserEntity>;\n}\n",
  "features/auth/domain/usecases/getUserById.usecase.ts": "import { type UserEntity } from '../entities';\nimport { type AuthRepository } from '../repositories/repository';\n\nexport interface GetUserByIdUseCase {\n\texecute: (dto: string) => Promise<UserEntity>;\n}\n\nexport class GetUserById implements GetUserByIdUseCase {\n\tconstructor(private readonly repository: AuthRepository) {}\n\n\tasync execute(dto: string): Promise<UserEntity> {\n\t\treturn await this.repository.getUserById(dto);\n\t}\n}\n",
  "features/auth/domain/usecases/index.ts": "export * from './register.usecase';\nexport * from './login.usecase';\nexport * from './getUserById.usecase';\n",
  "features/auth/domain/usecases/login.usecase.ts": "import { type LoginUserDto } from '../dtos';\nimport { type AuthEntity } from '../entities';\nimport { type AuthRepository } from '../repositories/repository';\n\nexport interface LoginUserUseCase {\n\texecute: (data: LoginUserDto) => Promise<AuthEntity>;\n}\n\nexport class LoginUser implements LoginUserUseCase {\n\tconstructor(private readonly repository: AuthRepository) {}\n\n\tasync execute(data: LoginUserDto): Promise<AuthEntity> {\n\t\treturn await this.repository.login(data);\n\t}\n}\n",
  "features/auth/domain/usecases/register.usecase.ts": "import { type RegisterUserDto } from '../dtos';\nimport { type AuthEntity } from '../entities';\nimport { type AuthRepository } from '../repositories/repository';\n\nexport interface RegisterUserUseCase {\n\texecute: (data: RegisterUserDto) => Promise<AuthEntity>;\n}\n\nexport class RegisterUser implements RegisterUserUseCase {\n\tconstructor(private readonly repository: AuthRepository) {}\n\n\tasync execute(data: RegisterUserDto): Promise<AuthEntity> {\n\t\treturn await this.repository.register(data);\n\t}\n}\n",
  "features/auth/index.ts": "export * from './presentation/controller';\nexport * from './presentation/routes';\nexport * from './presentation/middlewares';\nexport * from './domain';\nexport * from './infraestructure';\n",
  "features/auth/infraestructure/index.ts": "export * from './local.datasource.impl';\nexport * from './repository.impl';\n",
  "features/auth/infraestructure/local.datasource.impl.ts": "// src/features/auth/infraestructure/local.datasource.impl.ts\n\nimport { AppError, ONE, basicEncript, basicJWT } from '../../../core';\nimport { type RegisterUserDto, type AuthDatasource, UserEntity, AuthEntity, type LoginUserDto } from '../domain';\n\nconst USERS_MOCK = [\n\t{\n\t\tid: '1',\n\t\tname: 'Test User',\n\t\temail: 'test@test.com',\n\t\temailVerified: false,\n\t\tpassword: 'ca0711461f3b8387d01cc0c0cf532a4fb4b5fdf0207f7902fa75580718da497a',\n\t\trole: ['USER_ROLE'],\n\t\tavatar: 'https://avatars.dicebear.com/api/initials/T.svg'\n\t},\n\t{\n\t\tid: '2',\n\t\tname: 'Test User 2',\n\t\temail: 'test2@test.com',\n\t\temailVerified: false,\n\t\tpassword: 'ca0711461f3b8387d01cc0c0cf532a4fb4b5fdf0207f7902fa75580718da497a',\n\t\trole: ['USER_ROLE']\n\t}\n];\n\nexport class AuthDatasourceImpl implements AuthDatasource {\n\tpublic async register(dto: RegisterUserDto): Promise<AuthEntity> {\n\t\tconst user = USERS_MOCK.find((user) => user.email === dto.email);\n\t\tif (user) {\n\t\t\tthrow AppError.badRequest('User already exists', [{ constraint: 'User already exists', fields: ['email'] }]);\n\t\t}\n\t\tconst createdUser = {\n\t\t\t...dto,\n\t\t\tid: (USERS_MOCK.length + ONE).toString(),\n\t\t\temailVerified: false,\n\t\t\trole: ['USER_ROLE']\n\t\t};\n\t\t// Hash the password\n\t\tcreatedUser.password = basicEncript.hashPassword(dto.password);\n\t\t// Add the user to the mock\n\t\tUSERS_MOCK.push(createdUser);\n\t\t// Create the auth entity (omit the password)\n\t\tconst { password, ...rest } = UserEntity.fromJson(createdUser);\n\t\tconst token = basicJWT.generateToken({ id: createdUser.id });\n\t\t// ? Here you can verify if the token is created correctly before to send it to the client\n\t\treturn new AuthEntity(rest, token);\n\t}\n\n\tpublic async login(dto: LoginUserDto): Promise<AuthEntity> {\n\t\tconst user = USERS_MOCK.find((user) => user.email === dto.email);\n\t\tif (!user) throw AppError.badRequest('User with this email not found');\n\t\tconst isPasswordMatch = basicEncript.comparePassword(dto.password, user.password);\n\t\tif (!isPasswordMatch) throw AppError.badRequest('Invalid password');\n\t\tconst { password, ...rest } = UserEntity.fromJson({ ...user });\n\t\tconst token = basicJWT.generateToken({ id: user.id });\n\t\t// ? Here you can verify if the token is created correctly before to send it to the client\n\t\treturn new AuthEntity(rest, token);\n\t}\n\n\tpublic async getUserById(dto: string): Promise<UserEntity> {\n\t\tconst user = USERS_MOCK.find((user) => user.id === dto);\n\t\tif (!user) throw AppError.badRequest('User with this id not found');\n\t\treturn UserEntity.fromJson({ ...user });\n\t}\n}\n",
  "features/auth/infraestructure/repository.impl.ts": "// src/features/auth/infraestructure/repository.impl.ts\n\nimport {\n\ttype RegisterUserDto,\n\ttype AuthRepository,\n\ttype AuthEntity,\n\ttype AuthDatasource,\n\ttype LoginUserDto,\n\ttype UserEntity\n} from '../domain';\n\nexport class AuthRepositoryImpl implements AuthRepository {\n\tconstructor(private readonly datasource: AuthDatasource) {}\n\n\tpublic async register(dto: RegisterUserDto): Promise<AuthEntity> {\n\t\treturn await this.datasource.register(dto);\n\t}\n\n\tpublic async login(dto: LoginUserDto): Promise<AuthEntity> {\n\t\treturn await this.datasource.login(dto);\n\t}\n\n\tpublic async getUserById(dto: string): Promise<UserEntity> {\n\t\treturn await this.datasource.getUserById(dto);\n\t}\n}\n",
  "features/auth/presentation/controller.ts": "// src/features/auth/presentation/controller.ts\n\nimport { type NextFunction, type Request, type Response } from 'express';\n\nimport { HttpCode, type SuccessResponse } from '../../../core';\nimport {\n\ttype AuthRepository,\n\tRegisterUserDto,\n\tLoginUser,\n\ttype AuthEntity,\n\tRegisterUser,\n\tLoginUserDto\n} from '../domain';\n\ninterface RequestBodyLogin {\n\temail: string;\n\tpassword: string;\n}\n\ninterface RequestBodyRegister {\n\tname: string;\n\temail: string;\n\tpassword: string;\n}\n\nexport class AuthController {\n\t//* Dependency injection\n\tconstructor(private readonly repository: AuthRepository) {}\n\n\tpublic login = (\n\t\treq: Request<unknown, unknown, RequestBodyLogin>,\n\t\tres: Response<SuccessResponse<AuthEntity>>,\n\t\tnext: NextFunction\n\t): void => {\n\t\tconst { email, password } = req.body;\n\t\tconst dto = LoginUserDto.create({ email, password });\n\t\tnew LoginUser(this.repository)\n\t\t\t.execute(dto)\n\t\t\t.then((result) => res.json({ data: result }))\n\t\t\t.catch(next);\n\t};\n\n\tpublic register = (\n\t\treq: Request<unknown, unknown, RequestBodyRegister>,\n\t\tres: Response<SuccessResponse<AuthEntity>>,\n\t\tnext: NextFunction\n\t): void => {\n\t\tconst { email, name, password } = req.body;\n\t\tconst dto = RegisterUserDto.create({ email, name, password });\n\t\tnew RegisterUser(this.repository)\n\t\t\t.execute(dto)\n\t\t\t.then((result) => res.status(HttpCode.CREATED).json({ data: result }))\n\t\t\t.catch(next);\n\t};\n}\n",
  "features/auth/presentation/middlewares/auth.middleware.ts": "import { type Response, type NextFunction, type Request } from 'express';\nimport { AppError, ONE, basicJWT } from '../../../../core';\n\nimport { type AuthRepository, GetUserById } from '../../../auth';\n\nexport class AuthMiddleware {\n\t//* Dependency injection\n\tconstructor(private readonly repository: AuthRepository) {}\n\n\tpublic validateJWT = (req: Request, _: Response, next: NextFunction): void => {\n\t\tconst authorization = req.header('Authorization');\n\n\t\tif (!authorization) throw AppError.unauthorized('Unauthorized (no authorization header)');\n\n\t\tif (!authorization.startsWith('Bearer ')) {\n\t\t\tthrow AppError.unauthorized('Invalid authorization header (Bearer token required)');\n\t\t}\n\n\t\tconst token = authorization.split(' ').at(ONE) ?? '';\n\t\tconst payload = basicJWT.validateToken<{ id: string }>(token);\n\n\t\tif (!payload) throw AppError.unauthorized('Invalid token');\n\n\t\tnew GetUserById(this.repository)\n\t\t\t.execute(payload.id)\n\t\t\t.then((result) => {\n\t\t\t\treq.body.user = result;\n\t\t\t\tnext();\n\t\t\t})\n\t\t\t.catch(next);\n\t};\n}\n",
  "features/auth/presentation/middlewares/index.ts": "export * from './auth.middleware';\n",
  "features/auth/presentation/routes.ts": "// src/features/auth/presentation/routes.ts\n\nimport { Router } from 'express';\n\nimport { AuthController } from './controller';\nimport { AuthDatasourceImpl, AuthRepositoryImpl } from '../infraestructure';\n\nexport class AuthRoutes {\n\tstatic get routes(): Router {\n\t\tconst router = Router();\n\n\t\tconst datasource = new AuthDatasourceImpl();\n\t\tconst repository = new AuthRepositoryImpl(datasource);\n\t\tconst controller = new AuthController(repository);\n\n\t\trouter.post('/login', controller.login);\n\t\trouter.post('/register', controller.register);\n\n\t\treturn router;\n\t}\n}\n",
  "features/shared/domain/dtos/core.dto.ts": "export abstract class CoreDto<T> {\n\tabstract validate(dto: T): void;\n}\n",
  "features/shared/domain/dtos/index.ts": "export * from './pagination.dto';\nexport * from './core.dto';\n",
  "features/shared/domain/dtos/pagination.dto.ts": "import { AppError, ZERO, type ValidationType } from '../../../../core';\nimport { type CoreDto } from './core.dto';\n\nexport class PaginationDto implements CoreDto<PaginationDto> {\n\tprivate constructor(\n\t\tpublic readonly page: number,\n\t\tpublic readonly limit: number\n\t) {\n\t\tthis.validate(this);\n\t}\n\n\t/**\n\t * This method validates the properties of the PaginationDto class.\n\t * @param dto The instance of the PaginationDto class to be validated.\n\t * @returns void\n\t */\n\tpublic validate(dto: PaginationDto): void {\n\t\tconst errors: ValidationType[] = [];\n\n\t\tif (isNaN(dto.page) || isNaN(dto.limit)) {\n\t\t\terrors.push({ fields: ['page', 'limit'], constraint: 'Page and limit must be numbers' });\n\t\t}\n\n\t\tif (dto.page <= ZERO) {\n\t\t\terrors.push({ fields: ['page'], constraint: 'Page must be greater than zero' });\n\t\t}\n\n\t\tif (dto.limit <= ZERO) {\n\t\t\terrors.push({ fields: ['limit'], constraint: 'Limit must be greater than zero' });\n\t\t}\n\n\t\tif (errors.length > ZERO) throw AppError.badRequest('Error validating pagination', errors);\n\t}\n\n\t/**\n\t * This method creates a new instance of this DTO class with the given\n\t * properties from body or query parameters.\n\t * @param object\n\t * @returns A new instance of this DTO\n\t */\n\tpublic static create(object: Record<string, unknown>): PaginationDto {\n\t\tconst { page, limit } = object;\n\t\treturn new PaginationDto(page as number, limit as number);\n\t}\n}\n",
  "features/shared/domain/entities/index.ts": "export * from './paginationResponse.entity';\n",
  "features/shared/domain/entities/paginationResponse.entity.ts": "export class PaginationResponseEntity<T> {\n\tconstructor(\n\t\tpublic total: number,\n\t\tpublic totalPages: number,\n\t\tpublic currentPage: number,\n\t\tpublic nextPage: number | null,\n\t\tpublic prevPage: number | null,\n\t\tpublic results: T\n\t) {}\n}\n",
  "features/shared/domain/index.ts": "export * from './dtos';\nexport * from './entities';\n",
  "features/shared/index.ts": "export * from './domain';\nexport * from './presentation';\n",
  "features/shared/presentation/index.ts": "export * from './middlewares';\n",
  "features/shared/presentation/middlewares/custom.middleware.ts": "import { type Response, type NextFunction, type Request } from 'express';\n\nexport class CustomMiddlewares {\n\t//* Dependency injection\n\t// constructor() {}\n\n\tpublic static writeInConsole = (_req: Request, _res: Response, next: NextFunction): void => {\n\t\t// console.log('Hello from the Middleware');\n\t\tnext();\n\t};\n}\n",
  "features/shared/presentation/middlewares/error.middleware.ts": "import { type Response, type NextFunction, type Request } from 'express';\n\nimport { type ErrorResponse, HttpCode, AppError } from '../../../../core';\n\nexport class ErrorMiddleware {\n\t//* Dependency injection\n\t// constructor() {}\n\n\tpublic static handleError = (error: unknown, _: Request, res: Response<ErrorResponse>, next: NextFunction): void => {\n\t\tif (error instanceof AppError) {\n\t\t\tconst { message, name, stack, validationErrors } = error;\n\t\t\tconst statusCode = error.statusCode || HttpCode.INTERNAL_SERVER_ERROR;\n\t\t\tres.statusCode = statusCode;\n\t\t\tres.json({ name, message, validationErrors, stack });\n\t\t} else {\n\t\t\tconst name = 'InternalServerError';\n\t\t\tconst message = 'An internal server error occurred';\n\t\t\tconst statusCode = HttpCode.INTERNAL_SERVER_ERROR;\n\t\t\tres.statusCode = statusCode;\n\t\t\tres.json({ name, message });\n\t\t}\n\t\tnext();\n\t};\n}\n",
  "features/shared/presentation/middlewares/index.ts": "export * from './custom.middleware';\nexport * from './error.middleware';\n",
  "features/todos/domain/datasources/datasource.ts": "// src\\features\\todos\\domain\\datasources\\datasource.ts\n\nimport { type PaginationDto, type PaginationResponseEntity } from '../../../shared';\nimport { type UpdateTodoDto, type CreateTodoDto, type GetTodoByIdDto } from '../dtos';\nimport { type TodoEntity } from '../entities';\n\nexport abstract class TodoDatasource {\n\tabstract create(createDto: CreateTodoDto): Promise<TodoEntity>;\n\tabstract getAll(pagination: PaginationDto): Promise<PaginationResponseEntity<TodoEntity[]>>;\n\tabstract getById(getByIdDto: GetTodoByIdDto): Promise<TodoEntity>;\n\tabstract update(updateDto: UpdateTodoDto): Promise<TodoEntity>;\n\tabstract delete(getByIdDto: GetTodoByIdDto): Promise<TodoEntity>;\n}\n",
  "features/todos/domain/dtos/create.dto.ts": "import { type ValidationType, AppError, ZERO } from '../../../../core';\nimport { type CoreDto } from '../../../shared';\n\nexport class CreateTodoDto implements CoreDto<CreateTodoDto> {\n\tprivate constructor(public readonly text: string) {\n\t\tthis.validate(this);\n\t}\n\n\tpublic validate(dto: CreateTodoDto): void {\n\t\tconst errors: ValidationType[] = [];\n\n\t\tif (!dto.text || dto.text.length === ZERO) {\n\t\t\terrors.push({ fields: ['text'], constraint: 'Text is required' });\n\t\t}\n\n\t\tif (errors.length > ZERO) throw AppError.badRequest('Error validating create todo', errors);\n\t}\n\n\t/**\n\t * This method creates a new instance of this DTO class with the given\n\t * properties from body or query parameters.\n\t * @param object\n\t * @returns A new instance of this DTO\n\t */\n\tpublic static create(object: Record<string, unknown>): CreateTodoDto {\n\t\tconst { text } = object;\n\t\treturn new CreateTodoDto(text as string);\n\t}\n}\n",
  "features/todos/domain/dtos/getById.dto.ts": "import { type ValidationType, ZERO, AppError } from '../../../../core';\nimport { type CoreDto } from '../../../shared';\n\nexport class GetTodoByIdDto implements CoreDto<GetTodoByIdDto> {\n\tprivate constructor(public readonly id: number) {\n\t\tthis.validate(this);\n\t}\n\n\tpublic validate(dto: GetTodoByIdDto): void {\n\t\tconst errors: ValidationType[] = [];\n\n\t\tconst { id } = dto;\n\n\t\tif (!id || isNaN(Number(id))) {\n\t\t\terrors.push({ fields: ['id'], constraint: 'Id is not a valid number' });\n\t\t}\n\n\t\tif (errors.length > ZERO) throw AppError.badRequest('Error validating get todo by id', errors);\n\t}\n\n\t/**\n\t * This method creates a new instance of the DTO class with the given\n\t * properties from body or query parameters.\n\t * @param object\n\t * @returns A new instance of the DTO\n\t */\n\tpublic static create(object: Record<string, unknown>): GetTodoByIdDto {\n\t\tconst { id } = object;\n\t\treturn new GetTodoByIdDto(id as number);\n\t}\n}\n",
  "features/todos/domain/dtos/index.ts": "export * from './create.dto';\nexport * from './update.dto';\nexport * from './getById.dto';\n",
  "features/todos/domain/dtos/update.dto.ts": "import { type ValidationType, AppError, ZERO } from '../../../../core';\nimport { type CoreDto } from '../../../shared';\n\nexport class UpdateTodoDto implements CoreDto<UpdateTodoDto> {\n\tprivate constructor(\n\t\tpublic readonly id: number,\n\t\tpublic readonly text?: string,\n\t\tpublic readonly isCompleted?: boolean\n\t) {\n\t\tthis.validate(this);\n\t}\n\n\tpublic validate(dto: UpdateTodoDto): void {\n\t\tconst errors: ValidationType[] = [];\n\n\t\tconst { id, isCompleted } = dto;\n\n\t\tif (!id || isNaN(Number(id))) {\n\t\t\terrors.push({ fields: ['id'], constraint: 'Id is not a valid number' });\n\t\t}\n\n\t\tif (\n\t\t\tisCompleted !== undefined &&\n\t\t\ttypeof isCompleted !== 'boolean' &&\n\t\t\tisCompleted !== 'true' &&\n\t\t\tisCompleted !== 'false'\n\t\t) {\n\t\t\terrors.push({ fields: ['isCompleted'], constraint: 'isCompleted must be a valid value (true or false)' });\n\t\t}\n\n\t\tif (errors.length > ZERO) throw AppError.badRequest('Error validating update todo', errors);\n\t}\n\n\t/**\n\t * This method creates a new instance of the DTO class with the given\n\t * properties from body or query parameters.\n\t * @param object\n\t * @returns A new instance of the DTO\n\t */\n\tpublic static create(object: Record<string, unknown>): UpdateTodoDto {\n\t\tconst { id, text, isCompleted } = object;\n\t\treturn new UpdateTodoDto(id as number, text as string, isCompleted as boolean);\n\t}\n}\n",
  "features/todos/domain/entities/index.ts": "export * from './todo.entity';\n",
  "features/todos/domain/entities/todo.entity.ts": "// src\\features\\todos\\domain\\entities\\todo.entity.ts\n\nimport { AppError, ZERO } from '../../../../core';\n\nexport class TodoEntity {\n\tconstructor(\n\t\tpublic id: number,\n\t\tpublic text: string,\n\t\tpublic isCompleted: boolean = false\n\t) {}\n\n\tpublic static fromJson(obj: Record<string, unknown>): TodoEntity {\n\t\tconst { id, text, isCompleted = false } = obj;\n\t\tif (!id) {\n\t\t\tthrow AppError.badRequest('This entity requires an id', [{ constraint: 'id is required', fields: ['id'] }]);\n\t\t}\n\t\tif (!text || (text as string).length === ZERO) {\n\t\t\tthrow AppError.badRequest('This entity requires a text', [{ constraint: 'text is required', fields: ['text'] }]);\n\t\t}\n\t\treturn new TodoEntity(id as number, text as string, isCompleted as boolean);\n\t}\n}\n",
  "features/todos/domain/index.ts": "export * from './datasources/datasource';\nexport * from './dtos';\nexport * from './entities';\nexport * from './repositories/respository';\nexport * from './usecases';\n",
  "features/todos/domain/repositories/respository.ts": "// src\\features\\todos\\domain\\repositories\\respository.ts\n\nimport { type PaginationDto, type PaginationResponseEntity } from '../../../shared';\nimport { type GetTodoByIdDto, type UpdateTodoDto, type CreateTodoDto } from '../dtos';\nimport { type TodoEntity } from '../entities';\n\nexport abstract class TodoRepository {\n\tabstract create(createDto: CreateTodoDto): Promise<TodoEntity>;\n\tabstract getAll(pagination: PaginationDto): Promise<PaginationResponseEntity<TodoEntity[]>>;\n\tabstract getById(getByIdDto: GetTodoByIdDto): Promise<TodoEntity>;\n\tabstract update(updateDto: UpdateTodoDto): Promise<TodoEntity>;\n\tabstract delete(getByIdDto: GetTodoByIdDto): Promise<TodoEntity>;\n}\n",
  "features/todos/domain/usecases/create.usecase.ts": "import { type CreateTodoDto } from '../dtos';\nimport { type TodoEntity } from '../entities';\nimport { type TodoRepository } from '../repositories/respository';\n\nexport interface CreateTodoUseCase {\n\texecute: (data: CreateTodoDto) => Promise<TodoEntity>;\n}\n\nexport class CreateTodo implements CreateTodoUseCase {\n\tconstructor(private readonly repository: TodoRepository) {}\n\n\tasync execute(data: CreateTodoDto): Promise<TodoEntity> {\n\t\treturn await this.repository.create(data);\n\t}\n}\n",
  "features/todos/domain/usecases/delete.usecase.ts": "import { type GetTodoByIdDto } from '../dtos';\nimport { type TodoEntity } from '../entities';\nimport { type TodoRepository } from '../repositories/respository';\n\nexport interface DeleteTodoUseCase {\n\texecute: (getByIdDto: GetTodoByIdDto) => Promise<TodoEntity>;\n}\n\nexport class DeleteTodo implements DeleteTodoUseCase {\n\tconstructor(private readonly repository: TodoRepository) {}\n\n\tasync execute(getByIdDto: GetTodoByIdDto): Promise<TodoEntity> {\n\t\treturn await this.repository.delete(getByIdDto);\n\t}\n}\n",
  "features/todos/domain/usecases/getAll.usecase.ts": "import { type PaginationDto, type PaginationResponseEntity } from '../../../shared';\nimport { type TodoEntity } from '../entities';\nimport { type TodoRepository } from '../repositories/respository';\n\nexport interface GetTodosUseCase {\n\texecute: (pagination: PaginationDto) => Promise<PaginationResponseEntity<TodoEntity[]>>;\n}\n\nexport class GetTodos implements GetTodosUseCase {\n\tconstructor(private readonly repository: TodoRepository) {}\n\n\tasync execute(pagination: PaginationDto): Promise<PaginationResponseEntity<TodoEntity[]>> {\n\t\treturn await this.repository.getAll(pagination);\n\t}\n}\n",
  "features/todos/domain/usecases/getById.usecase.ts": "import { type GetTodoByIdDto } from '../dtos';\nimport { type TodoEntity } from '../entities';\nimport { type TodoRepository } from '../repositories/respository';\n\nexport interface GetTodoByIdUseCase {\n\texecute: (getByIdDto: GetTodoByIdDto) => Promise<TodoEntity>;\n}\n\nexport class GetTodoById implements GetTodoByIdUseCase {\n\tconstructor(private readonly repository: TodoRepository) {}\n\n\tasync execute(getByIdDto: GetTodoByIdDto): Promise<TodoEntity> {\n\t\treturn await this.repository.getById(getByIdDto);\n\t}\n}\n",
  "features/todos/domain/usecases/index.ts": "export * from './create.usecase';\nexport * from './delete.usecase';\nexport * from './update.usecase';\nexport * from './getAll.usecase';\nexport * from './getById.usecase';\n",
  "features/todos/domain/usecases/update.usecase.ts": "import { type UpdateTodoDto } from '../dtos';\nimport { type TodoEntity } from '../entities';\nimport { type TodoRepository } from '../repositories/respository';\n\nexport interface UpdateTodoUseCase {\n\texecute: (data: UpdateTodoDto) => Promise<TodoEntity>;\n}\n\nexport class UpdateTodo implements UpdateTodoUseCase {\n\tconstructor(private readonly repository: TodoRepository) {}\n\n\tasync execute(data: UpdateTodoDto): Promise<TodoEntity> {\n\t\treturn await this.repository.update(data);\n\t}\n}\n",
  "features/todos/index.ts": "export * from './domain';\nexport * from './infraestructure';\nexport * from './presentation/controller';\nexport * from './presentation/routes';\n",
  "features/todos/infraestructure/index.ts": "export * from './local.datasource.impl';\nexport * from './repository.impl';\n",
  "features/todos/infraestructure/local.datasource.impl.ts": "// src\\features\\todos\\infraestructure\\local.datasource.impl.ts\n\nimport { ONE, ZERO, AppError } from '../../../core';\nimport { type PaginationDto, type PaginationResponseEntity } from '../../shared';\nimport {\n\tTodoEntity,\n\ttype CreateTodoDto,\n\ttype GetTodoByIdDto,\n\ttype UpdateTodoDto,\n\ttype TodoDatasource\n} from '../domain';\n\nconst TODOS_MOCK = [\n\t{\n\t\tid: 1,\n\t\ttext: 'First TODO...',\n\t\tisCompleted: false\n\t},\n\t{\n\t\tid: 2,\n\t\ttext: 'Second TODO...',\n\t\tisCompleted: false\n\t}\n];\n\nexport class TodoDatasourceImpl implements TodoDatasource {\n\tpublic async getAll(pagination: PaginationDto): Promise<PaginationResponseEntity<TodoEntity[]>> {\n\t\tconst { page, limit } = pagination;\n\n\t\tconst todos = TODOS_MOCK;\n\t\tconst total = TODOS_MOCK.length;\n\n\t\tconst totalPages = Math.ceil(total / limit);\n\t\tconst nextPage = page < totalPages ? page + ONE : null;\n\t\tconst prevPage = page > ONE ? page - ONE : null;\n\n\t\treturn {\n\t\t\tresults: todos.slice((page - ONE) * limit, page * limit).map((todo) => TodoEntity.fromJson(todo)),\n\t\t\tcurrentPage: page,\n\t\t\tnextPage,\n\t\t\tprevPage,\n\t\t\ttotal,\n\t\t\ttotalPages\n\t\t};\n\t}\n\n\tpublic async getById(getByIdDto: GetTodoByIdDto): Promise<TodoEntity> {\n\t\tconst todo = TODOS_MOCK.find((todo) => todo.id === getByIdDto.id);\n\t\tif (!todo) throw AppError.notFound(`Todo with id ${getByIdDto.id} not found`);\n\t\treturn TodoEntity.fromJson(todo);\n\t}\n\n\tpublic async create(createDto: CreateTodoDto): Promise<TodoEntity> {\n\t\tconst createdTodo = { id: TODOS_MOCK.length + ONE, ...createDto, isCompleted: false };\n\t\tTODOS_MOCK.push(createdTodo);\n\t\treturn TodoEntity.fromJson(createdTodo);\n\t}\n\n\tpublic async update(updateDto: UpdateTodoDto): Promise<TodoEntity> {\n\t\tconst { id } = await this.getById(updateDto);\n\t\tconst index = TODOS_MOCK.findIndex((todo) => todo.id === id);\n\n\t\tTODOS_MOCK[index] = {\n\t\t\t...TODOS_MOCK[index],\n\t\t\t...Object.fromEntries(Object.entries(updateDto).filter(([_, v]) => v !== undefined))\n\t\t};\n\n\t\treturn TodoEntity.fromJson(TODOS_MOCK[index]);\n\t}\n\n\tpublic async delete(getByIdDto: GetTodoByIdDto): Promise<TodoEntity> {\n\t\tconst { id } = await this.getById(getByIdDto);\n\t\tconst index = TODOS_MOCK.findIndex((todo) => todo.id === id);\n\t\tconst deletedTodo = TODOS_MOCK.splice(index, ONE)[ZERO];\n\t\treturn TodoEntity.fromJson(deletedTodo);\n\t}\n}\n",
  "features/todos/infraestructure/repository.impl.ts": "// src\\features\\todos\\infraestructure\\repository.impl.ts\n\nimport { type PaginationDto, type PaginationResponseEntity } from '../../shared';\n\nimport {\n\ttype TodoEntity,\n\ttype TodoDatasource,\n\ttype GetTodoByIdDto,\n\ttype UpdateTodoDto,\n\ttype CreateTodoDto,\n\ttype TodoRepository\n} from '../domain';\n\nexport class TodoRepositoryImpl implements TodoRepository {\n\tconstructor(private readonly datasource: TodoDatasource) {}\n\n\tasync create(createDto: CreateTodoDto): Promise<TodoEntity> {\n\t\treturn await this.datasource.create(createDto);\n\t}\n\n\tasync getAll(pagination: PaginationDto): Promise<PaginationResponseEntity<TodoEntity[]>> {\n\t\treturn await this.datasource.getAll(pagination);\n\t}\n\n\tasync getById(getByIdDto: GetTodoByIdDto): Promise<TodoEntity> {\n\t\treturn await this.datasource.getById(getByIdDto);\n\t}\n\n\tasync update(updateDto: UpdateTodoDto): Promise<TodoEntity> {\n\t\treturn await this.datasource.update(updateDto);\n\t}\n\n\tasync delete(getByIdDto: GetTodoByIdDto): Promise<TodoEntity> {\n\t\treturn await this.datasource.delete(getByIdDto);\n\t}\n}\n",
  "features/todos/presentation/controller.ts": "// src\\features\\todos\\presentation\\controller.ts\n\nimport { type NextFunction, type Request, type Response } from 'express';\n\nimport { type SuccessResponse, HttpCode, ONE, TEN } from '../../../core';\nimport { PaginationDto, type PaginationResponseEntity } from '../../shared';\n\nimport {\n\tCreateTodo,\n\tDeleteTodo,\n\tGetTodoById,\n\tUpdateTodo,\n\tCreateTodoDto,\n\tGetTodoByIdDto,\n\tUpdateTodoDto,\n\tGetTodos,\n\ttype TodoEntity,\n\ttype TodoRepository\n} from '../domain';\n\ninterface Params {\n\tid: string;\n}\n\ninterface RequestBody {\n\ttext: string;\n\tisCompleted: string;\n}\n\ninterface RequestQuery {\n\tpage: string;\n\tlimit: string;\n}\n\nexport class TodoController {\n\t//* Dependency injection\n\tconstructor(private readonly repository: TodoRepository) {}\n\n\tpublic getAll = (\n\t\treq: Request<unknown, unknown, unknown, RequestQuery>,\n\t\tres: Response<SuccessResponse<PaginationResponseEntity<TodoEntity[]>>>,\n\t\tnext: NextFunction\n\t): void => {\n\t\tconst { page = ONE, limit = TEN } = req.query;\n\t\tconst paginationDto = PaginationDto.create({ page: +page, limit: +limit });\n\t\tnew GetTodos(this.repository)\n\t\t\t.execute(paginationDto)\n\t\t\t.then((result) => res.json({ data: result }))\n\t\t\t.catch((error) => {\n\t\t\t\tnext(error);\n\t\t\t});\n\t};\n\n\tpublic getById = (req: Request<Params>, res: Response<SuccessResponse<TodoEntity>>, next: NextFunction): void => {\n\t\tconst { id } = req.params;\n\t\tconst getTodoByIdDto = GetTodoByIdDto.create({ id: Number(id) });\n\t\tnew GetTodoById(this.repository)\n\t\t\t.execute(getTodoByIdDto)\n\t\t\t.then((result) => res.json({ data: result }))\n\t\t\t.catch(next);\n\t};\n\n\tpublic create = (\n\t\treq: Request<unknown, unknown, RequestBody>,\n\t\tres: Response<SuccessResponse<TodoEntity>>,\n\t\tnext: NextFunction\n\t): void => {\n\t\tconst { text } = req.body;\n\t\tconst createDto = CreateTodoDto.create({ text });\n\t\tnew CreateTodo(this.repository)\n\t\t\t.execute(createDto)\n\t\t\t.then((result) => res.status(HttpCode.CREATED).json({ data: result }))\n\t\t\t.catch(next);\n\t};\n\n\tpublic update = (\n\t\treq: Request<Params, unknown, RequestBody>,\n\t\tres: Response<SuccessResponse<TodoEntity>>,\n\t\tnext: NextFunction\n\t): void => {\n\t\tconst { id } = req.params;\n\t\tconst { text, isCompleted } = req.body;\n\t\tconst updateDto = UpdateTodoDto.create({ id: Number(id), text, isCompleted });\n\t\tnew UpdateTodo(this.repository)\n\t\t\t.execute(updateDto)\n\t\t\t.then((result) => res.json({ data: result }))\n\t\t\t.catch(next);\n\t};\n\n\tpublic delete = (req: Request<Params>, res: Response<SuccessResponse<TodoEntity>>, next: NextFunction): void => {\n\t\tconst { id } = req.params;\n\t\tconst getTodoByIdDto = GetTodoByIdDto.create({ id: Number(id) });\n\t\tnew DeleteTodo(this.repository)\n\t\t\t.execute(getTodoByIdDto)\n\t\t\t.then((result) => res.json({ data: result }))\n\t\t\t.catch(next);\n\t};\n}\n",
  "features/todos/presentation/routes.ts": "// src\\features\\todos\\presentation\\routes.ts\n\nimport { Router } from 'express';\n\nimport { TodoDatasourceImpl, TodoRepositoryImpl } from '../infraestructure';\nimport { TodoController } from './controller';\nimport { AuthDatasourceImpl, AuthMiddleware, AuthRepositoryImpl } from '../../auth';\n\nexport class TodoRoutes {\n\tstatic get routes(): Router {\n\t\tconst router = Router();\n\n\t\t//* This datasource can be change\n\t\tconst datasource = new TodoDatasourceImpl();\n\t\tconst repository = new TodoRepositoryImpl(datasource);\n\t\tconst controller = new TodoController(repository);\n\n\t\t// * Authentication middleware\n\t\tconst authDatasource = new AuthDatasourceImpl();\n\t\tconst authRepository = new AuthRepositoryImpl(authDatasource);\n\t\tconst authMiddleware = new AuthMiddleware(authRepository);\n\n\t\trouter.get('/', controller.getAll);\n\t\trouter.get('/:id', controller.getById);\n\t\trouter.post('/', [authMiddleware.validateJWT], controller.create);\n\t\trouter.put('/:id', controller.update);\n\t\trouter.delete('/:id', controller.delete);\n\n\t\t// rest of operations\n\t\t// ...\n\n\t\treturn router;\n\t}\n}\n",
  "routes.ts": "// src\\routes.ts\n\nimport { Router } from 'express';\n\nimport { TodoRoutes } from './features/todos';\nimport { AuthRoutes } from './features/auth';\n\nexport class AppRoutes {\n\tstatic get routes(): Router {\n\t\tconst router = Router();\n\n\t\trouter.use('/auth', AuthRoutes.routes);\n\t\trouter.use('/todos', TodoRoutes.routes);\n\n\t\t// rest of routes\n\t\t// ...\n\n\t\treturn router;\n\t}\n}\n",
  "server.ts": "// src\\server.ts\n\nimport { type Server as ServerHttp, type IncomingMessage, type ServerResponse } from 'http';\nimport express, { type Router, type Request, type Response, type NextFunction } from 'express';\nimport compression from 'compression';\nimport rateLimit from 'express-rate-limit';\n\nimport { HttpCode, ONE_HUNDRED, ONE_THOUSAND, SIXTY, AppError } from './core';\nimport { CustomMiddlewares, ErrorMiddleware } from './features/shared';\n\ninterface ServerOptions {\n\tport: number;\n\troutes: Router;\n\tapiPrefix: string;\n}\n\nexport class Server {\n\tpublic readonly app = express(); // This is public for testing purposes\n\tprivate serverListener?: ServerHttp<typeof IncomingMessage, typeof ServerResponse>;\n\tprivate readonly port: number;\n\tprivate readonly routes: Router;\n\tprivate readonly apiPrefix: string;\n\n\tconstructor(options: ServerOptions) {\n\t\tconst { port, routes, apiPrefix } = options;\n\t\tthis.port = port;\n\t\tthis.routes = routes;\n\t\tthis.apiPrefix = apiPrefix;\n\t}\n\n\tasync start(): Promise<void> {\n\t\t//* Middlewares\n\t\tthis.app.use(express.json()); // parse json in request body (allow raw)\n\t\tthis.app.use(express.urlencoded({ extended: true })); // allow x-www-form-urlencoded\n\t\tthis.app.use(compression());\n\t\t//  limit repeated requests to public APIs\n\t\tthis.app.use(\n\t\t\trateLimit({\n\t\t\t\tmax: ONE_HUNDRED,\n\t\t\t\twindowMs: SIXTY * SIXTY * ONE_THOUSAND,\n\t\t\t\tmessage: 'Too many requests from this IP, please try again in one hour'\n\t\t\t})\n\t\t);\n\n\t\t// Shared Middlewares\n\t\tthis.app.use(CustomMiddlewares.writeInConsole);\n\n\t\t// CORS\n\t\tthis.app.use((req, res, next) => {\n\t\t\t// Add your origins\n\t\t\tconst allowedOrigins = ['http://localhost:3000'];\n\t\t\tconst origin = req.headers.origin;\n\t\t\t// TODO: Fix this\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\tif (allowedOrigins.includes(origin!)) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t\tres.setHeader('Access-Control-Allow-Origin', origin!);\n\t\t\t}\n\t\t\t// Do not forget to add all the necessary methods and headers to avoid CORS problems\n\t\t\tres.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n\t\t\t// For example, if you are going to use authorization headers do not forget to add it here\n\t\t\tres.setHeader('Access-Control-Allow-Headers', 'Content-Type, Accept, Authorization');\n\t\t\tnext();\n\t\t});\n\n\t\t//* Routes\n\t\tthis.app.use(this.apiPrefix, this.routes);\n\n\t\t// Test rest api\n\t\tthis.app.get('/', (_req: Request, res: Response) => {\n\t\t\tres.status(HttpCode.OK).send({\n\t\t\t\tmessage: `Welcome to Initial API! \\n Endpoints available at http://localhost:${this.port}${this.apiPrefix}`\n\t\t\t});\n\t\t});\n\n\t\t//* Handle not found routes in /api/v1/* (only if 'Public content folder' is not available)\n\t\tthis.routes.all('*', (req: Request, _: Response, next: NextFunction): void => {\n\t\t\tnext(AppError.notFound(`Cant find ${req.originalUrl} on this server!`));\n\t\t});\n\n\t\t// Handle errors middleware\n\t\tthis.routes.use(ErrorMiddleware.handleError);\n\n\t\tthis.serverListener = this.app.listen(this.port, () => {\n\t\t\tconsole.log(`Server running on port ${this.port}...`);\n\t\t});\n\t}\n\n\tclose(): void {\n\t\tthis.serverListener?.close();\n\t}\n}\n"
  
}